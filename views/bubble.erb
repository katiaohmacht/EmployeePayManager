<style>

#canvas-container {
    display: flex;
    margin-top:5%;
    justify-content: center;
    height: 100vh; /* Adjust this to the desired height */
    margin-bottom: 1%;
}

#canvas {
    width: 85%;
    height: 70%;
    background-color: whitesmoke;
    border-radius: 2%;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    padding: 2%;
    border: 2px solid #D8F3EC;
    overflow: hidden;
}

#container-1 {
  padding:2%;
  margin-left:7%;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 15%;
  background-color: paleturquoise;
  margin-top: 2%;
  width: 85%;
  border-radius: 25px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);s
}

#container-1 h1 {
  margin: 0;
  color: whitesmoke;
  text-align: center;
  line-height: 100%;
  z-index: 1;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}
.myTitle {
  font-size: 80px;
  color: whitesmoke;
}



</style>

<div class = "right">
	<div id = "container-1"><h1 class = "myTitle">Draw Bubbles!</h1></div>

	<div id = "canvas-container">
		<canvas id="canvas"></canvas>
	</div>
</div>



<script> 

const displayCanvas = document.getElementById('canvas'); // Get the canvas element
const context = displayCanvas.getContext('2d'); // Get the 2D rendering context

// Set canvas dimensions to match window dimensions
displayCanvas.width = window.innerWidth;
displayCanvas.height = window.innerHeight;

console.log(context);

// Create a gradient for fill style
let gradient = context.createLinearGradient(0, 0, displayCanvas.width, 0);
gradient.addColorStop(0, 'lightgreen');
gradient.addColorStop(0.5, 'lightblue');
gradient.addColorStop(1, 'violet');
context.fillStyle = gradient;

class Particle {
    constructor(effect) {
        this.effect = effect;
        this.radius = 0.3;
        this.minRadius = this.radius;
        this.maxRadius = Math.random() * 75 + 22;
        this.x = this.radius + Math.random() * (this.effect.width - this.radius * 2);
        this.y = this.radius + Math.random() * (this.effect.height - this.radius * 2);
        this.vx = Math.random() * 0.15 - 0.1;
        this.vy = Math.random() * 0.15 - 0.1;
    }
    
    draw(context) {
        if (this.radius > 0.4) {
            context.fillStyle = gradient;
            context.beginPath();
            context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            context.fill();
            context.stroke();

            context.fillStyle = 'rgba(255,255,255,0.6)';
            context.beginPath();
            context.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.4, this.radius * 0.5, 0, Math.PI * 2);
            context.fill();
        }
    }
    
    update() {
        // Calculate distance from mouse
        const dx = this.x - this.effect.mouse.x;
        const dy = this.y - this.effect.mouse.y;
        const distance = Math.hypot(dx, dy);

        // Adjust particle size based on mouse proximity
        if (distance < this.effect.mouse.radius && this.radius < this.maxRadius) {
            this.radius += 5;
        }

        // Adjust particle size when mouse is not pressed
        if (!this.effect.mouse.pressed && this.radius > this.minRadius) {
            this.radius -= 1; // Adjust the decrease rate when the mouse is not pressed

            if (this.radius <= 0) {
                this.reset();
            }
        }

        // Update particle position
        this.x += this.vx;
        this.y += this.vy;

        // Bounce off canvas edges
        if (this.x < this.radius) {
            this.x = this.radius;
            this.vx *= -1;
        } else if (this.x > this.effect.width - this.radius) {
            this.x = this.effect.width - this.radius;
            this.vx *= -1;
        }

        if (this.y < this.radius) {
            this.y = this.radius;
            this.vy *= -1;
        } else if (this.y > this.effect.height - this.radius) {
            this.y = this.effect.height - this.radius;
            this.vy *= -1;
        }
    }
    
    reset() {
        this.x = this.radius + Math.random() * (this.effect.width - this.radius * 2);
        this.y = this.radius + Math.random() * (this.effect.height - this.radius * 2);
        this.radius = this.minRadius;
    }
}

// Define the effect class
class Effect {
    constructor(canvas, context) {
        this.canvas = canvas;
        this.context = context;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.particles = [];
        this.numParticles = 3000;
        this.createParticles();
        this.angle = 0;

        this.mouse = {
            x: 0,
            y: 0,
            pressed: false,
            radius: 60
        }

        // Event listeners for mouse interactions and window resize
        window.addEventListener('resize', e => {
            this.resize(e.target.window.innerWidth, e.target.window.innerHeight);
        });
        
        window.addEventListener('mousemove', e => {
            const mousePos = getMousePos(this.canvas, e);
            if (this.mouse.pressed) {
                this.mouse.x = mousePos.x;
                this.mouse.y = mousePos.y;
            }
        });
        
        window.addEventListener('mousedown', e => {
            this.mouse.pressed = true;
            const mousePos = getMousePos(this.canvas, e);
            this.mouse.x = mousePos.x;
            this.mouse.y = mousePos.y;
        });
        
        window.addEventListener('mouseup', e => {
            this.mouse.pressed = false;
        });
    }
    
    // Create particles and push them into the particles array
    createParticles() {
        for (let i = 0; i < this.numParticles; i++) {
            this.particles.push(new Particle(this));
        }
    }
    
    // Handle particle drawing and updating
    moveParticles(context) {
        this.particles.forEach(particle => {
            particle.draw(context);
            particle.update();
        });
    }
    

 	// Resize the canvas and particles when the window is resized
    resize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.width = width;
        this.height = height;
        gradient = context.createLinearGradient(0, 0, displayCanvas.width, 0);
        gradient.addColorStop(0, 'lightgreen');
        gradient.addColorStop(0.5, 'lightblue');
        gradient.addColorStop(1, 'violet');
        this.context.fillStyle = gradient;
        this.particles.forEach(particle => {
            particle.reset();
        });
    }
}

const particleEffect = new Effect(displayCanvas, context); // Create the particle effect

function animate() {
    context.clearRect(0, 0, displayCanvas.width, displayCanvas.height); // Clear the canvas
    particleEffect.moveParticles(context); // Handle and draw particles
    requestAnimationFrame(animate); // Request the next animation frame
}

// Start the animation loop
animate();

// Get mouse position relative to the canvas
function getMousePos(canvas, evt) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY
    }
}


</script>