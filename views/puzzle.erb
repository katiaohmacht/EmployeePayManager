<style>



	.canvas-container {
		position: relative;
		justify-content: center; /* Center horizontally */
		align-items: center; /* Center vertically */
		overflow: hidden;
		margin: 0 auto; /* Added code for horizontal centering */
		width: 95%;
		background-color: #F0B49D;
		padding: 2%;
		margin-right: 5%;
		border-radius: 2%;
		margin-bottom: 1%;
    height: 73.5%;

	}


	.frame {
		position: absolute;
		top: -10px;
		left: -10px;
		right: -10px;
		bottom: -10px;
		border: 10px solid #000;
		border-radius: 10px;
		z-index: -1;
	}

	  .text-wrapper {
    text-align: center;
    position: relative;
  }

  .text-wrapper h2 {
    display: inline-block;
    position: relative;
    padding-bottom: 0.2%;
    color: whitesmoke;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }

  .text-wrapper h2::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 110%;
    height: 2px;
    background-color: #000;
  }

    .imageOptions {
      position: relative;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      margin: 0 auto;
      width: 95%;
      background-color: #F0B49D;
      padding: 2%;
      margin-right: 5%;
      border-radius: 2%;
    }


    .bar_gen{
    	  position: relative;
	      justify-content: center;
	      align-items: center;
	      background-color: paleturquoise;
	      margin: 0 auto;
	      padding: 1%;
	      margin-right: 5%;
	      border-radius: 3%;
	      width: 50vh;

	      display: flex;
		  margin: 0 auto;
		  margin-top: 2%;
		  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);

    }

    #generateBtn{
    	display: flex;
        justify-content: center; 
  	    align-items: center; 
  	    margin: 0 auto;
  	    width: 4vw;
      	height: 4vw;
  	    background-color: white;
  	    border-radius: 50%;
  	    padding: 2%;
  	    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
    }

     #generateBtn:hover {
      border: 3px solid darkcyan;
    }

    #generateBtn:active{
    	background-color: darkcyan;
    }


    #difficulty{
    	width: 4vw;

    }

    #timer{
    	display: flex;
        justify-content: center; 
  	    align-items: center; 

    	width: 5vw;
      height: 5vw;
  	  border-radius: 50%;

    }

    #timer:hover svg path{
    	fill: darkcyan;
    }

    #timer:active svg path{
    	fill: #0e7d7d;
    }


    .base-timer {
		  position: relative;
		  width: 4.5vw;
		  height: 4.5vw;

		}

.base-timer__svg {
  transform: scaleX(-1);
}

.base-timer__circle {
  fill: none;
  stroke: none;
}

.base-timer__path-elapsed {
  stroke-width: 7px;
  stroke: grey;
}

.base-timer__path-remaining {
  stroke-width: 7px;
  stroke-linecap: round;
  transform: rotate(90deg);
  transform-origin: center;
  transition: 1s linear all;
  fill-rule: nonzero;
  stroke: currentColor;
}

.base-timer__path-remaining.green {
  color: rgb(65, 184, 131);
}

.base-timer__path-remaining.orange {
  color: orange;
}

.base-timer__path-remaining.red {
  color: red;
}

.base-timer__label {
  position: absolute;
  width: 4.5vw;
  height: 4.5vw;
  top: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5vw;
}

  .bar_gen{
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      grid-gap: 10px;
      margin-top: 20px;
      }


      .options{
      	width: 8vw; 
      	height: 5vw;
      	border: 1px solid floralwhite;
      }

        .image_options{
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
      grid-gap:20px;
      }


</style>
<div class = "right" id = "right" style = "background-color: #E3F8FF;">
	<div class = "canvas-container" id="canvas_container">
		<div class = "text-wrapper">
	      <h2> Puzzle </h2>
	    </div>
		<canvas id = "canvas"></canvas>
		
		<div class = "bar_gen">
			<div id = "timer" class = "timer">
<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" fill="currentColor" class="bi bi-stopwatch-fill" viewBox="0 0 16 16">
  <path d="M6.5 0a.5.5 0 0 0 0 1H7v1.07A7.001 7.001 0 0 0 8 16a7 7 0 0 0 5.29-11.584.531.531 0 0 0 .013-.012l.354-.354.353.354a.5.5 0 1 0 .707-.707l-1.414-1.415a.5.5 0 1 0-.707.707l.354.354-.354.354a.717.717 0 0 0-.012.012A6.973 6.973 0 0 0 9 2.071V1h.5a.5.5 0 0 0 0-1h-3zm2 5.6V9a.5.5 0 0 1-.5.5H4.5a.5.5 0 0 1 0-1h3V5.6a.5.5 0 1 1 1 0z"/>
</svg>
			</div>
			<div id="timeLeft"></div>
			<div id="generateBtn" class = "generateBtn">
				<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" fill="currentColor" class="bi bi-puzzle-fill" viewBox="0 0 16 16">
	  <path d="M3.112 3.645A1.5 1.5 0 0 1 4.605 2H7a.5.5 0 0 1 .5.5v.382c0 .696-.497 1.182-.872 1.469a.459.459 0 0 0-.115.118.113.113 0 0 0-.012.025L6.5 4.5v.003l.003.01c.004.01.014.028.036.053a.86.86 0 0 0 .27.194C7.09 4.9 7.51 5 8 5c.492 0 .912-.1 1.19-.24a.86.86 0 0 0 .271-.194.213.213 0 0 0 .036-.054l.003-.01v-.008a.112.112 0 0 0-.012-.025.459.459 0 0 0-.115-.118c-.375-.287-.872-.773-.872-1.469V2.5A.5.5 0 0 1 9 2h2.395a1.5 1.5 0 0 1 1.493 1.645L12.645 6.5h.237c.195 0 .42-.147.675-.48.21-.274.528-.52.943-.52.568 0 .947.447 1.154.862C15.877 6.807 16 7.387 16 8s-.123 1.193-.346 1.638c-.207.415-.586.862-1.154.862-.415 0-.733-.246-.943-.52-.255-.333-.48-.48-.675-.48h-.237l.243 2.855A1.5 1.5 0 0 1 11.395 14H9a.5.5 0 0 1-.5-.5v-.382c0-.696.497-1.182.872-1.469a.459.459 0 0 0 .115-.118.113.113 0 0 0 .012-.025L9.5 11.5v-.003l-.003-.01a.214.214 0 0 0-.036-.053.859.859 0 0 0-.27-.194C8.91 11.1 8.49 11 8 11c-.491 0-.912.1-1.19.24a.859.859 0 0 0-.271.194.214.214 0 0 0-.036.054l-.003.01v.002l.001.006a.113.113 0 0 0 .012.025c.016.027.05.068.115.118.375.287.872.773.872 1.469v.382a.5.5 0 0 1-.5.5H4.605a1.5 1.5 0 0 1-1.493-1.645L3.356 9.5h-.238c-.195 0-.42.147-.675.48-.21.274-.528.52-.943.52-.568 0-.947-.447-1.154-.862C.123 9.193 0 8.613 0 8s.123-1.193.346-1.638C.553 5.947.932 5.5 1.5 5.5c.415 0 .733.246.943.52.255.333.48.48.675.48h.238l-.244-2.855z"/>
			</svg>
		</div>
		<div id = "difficulty">
		<label for = "difficulty">Difficulty</label>
		<input type = "range" min = "2" max = "16" value = "4" id = "difficulty"/>
	</div>
	</div>
</div>
	<div class = "imageOptions">
		<div class = "image_options">


  			<img class = "options" id = "option" src = "/puzzle_images/rain.jpg" alt = "rain">


			<img class = "options" id = "leaf" src = "/puzzle_images/leaf.jpg" alt = "leaf">
			<img class = "options" id = "flower" src = "/puzzle_images/flower.jpg" alt = "flower">
			<img class = "options" id = "pond" src = "/puzzle_images/pond.jpg" alt = "pond">
			<img class = "options" id = "dog" src = "/puzzle_images/dog.jpg" alt = "dog">
			<img class = "options" id = "brush" src = "/puzzle_images/brush.jpg" alt = "brush">
			<img class = "options" id = "jungle" src = "/puzzle_images/jungle.jpg" alt = "jungle">
			<img class = "options" id = "sunset" src = "/puzzle_images/sunset.jpg" alt = "sunset">
			<img class = "options" id = "landscape" src = "/puzzle_images/landscape.jpg" alt = "landscape">
			<img class = "options" id = "ocean" src = "/puzzle_images/ocean.jpg" alt = "ocean">
			<img class = "options" id = "duck" src = "/puzzle_images/duck.jpg" alt = "duck">
			<img class = "options" id = "dandelion" src = "/puzzle_images/dandelion.jpg" alt = "dandelion">
			<img class = "options" id = "boat" src = "/puzzle_images/boat.jpg" alt = "boat">
			<img class = "options" id = "butterflies" src = "/puzzle_images/butterflies.jpg" alt = "butterflies">

			
		</div>
	</div>
</div>

<script>





  const PUZZLE_HOVER_TINT = "#009900";
  const img = new Image();
  const canvas = document.querySelector("#canvas");
  const stage = canvas.getContext("2d");
  let difficulty = 4;
  let pieces;
  let puzzleWidth;
  let puzzleHeight;
  let pieceWidth;
  let pieceHeight;
  let currentPiece;
  let currentDropPiece;
  let mouse;



  img.addEventListener("load", onImage, false);
  img.src = "/puzzle_images/rain.jpg";

  // Select specific image
  const imageOptions = document.querySelectorAll(".options");
  imageOptions.forEach(function (option) {
    option.addEventListener("click", function () {
      console.log("hi");
      const uploadedImage = new Image();

        uploadedImage.onload = function () {
//          const maxWidth = 800; // Maximum width for the image
          const maxHeight = 1000; // Maximum height for the image

          // Calculate new dimensions while maintaining the aspect ratio
          let newWidth = uploadedImage.width;
          let newHeight = uploadedImage.height;

          if (newHeight > maxHeight) {
            const aspectRatio = maxHeight / newHeight;
            newHeight = maxHeight;
            newWidth *= aspectRatio;
          }

          img.onload = function () {
            canvas.width = newWidth; // Set the canvas width to match the scaled image width
            canvas.height = newHeight; // Set the canvas height to match the scaled image height
            stage.clearRect(0, 0, newWidth, newHeight); // Clear the canvas
            stage.drawImage(img, 0, 0, newWidth, newHeight); // Draw the scaled image on the canvas
          };
          
          img.src = option.src;
          img.width = newWidth; // Set the new width for the image
          img.height = newHeight; // Set the new height for the image
        };

        uploadedImage.src = option.src;
    });
  });

 



  // Generate puzzle
  let generateBtn = document.querySelector(".generateBtn");
  generateBtn.addEventListener("click", () => {
    shufflePuzzle();
  });

  // Countdown

    const FULL_DASH_ARRAY = 283;
const WARNING_THRESHOLD = 60;
const ALERT_THRESHOLD = 10;

const COLOR_CODES = {
  info: {
    color: "green"
  },
  warning: {
    color: "orange",
    threshold: WARNING_THRESHOLD
  },
  alert: {
    color: "red",
    threshold: ALERT_THRESHOLD
  }
};

const TIME_LIMIT = 300;
let timePassed = 0;
let timeLeft = TIME_LIMIT;
let timerInterval = null;
let remainingPathColor = COLOR_CODES.info.color;

document.getElementById("timeLeft").innerHTML = `
<div class="base-timer">
  <svg class="base-timer__svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
    <g class="base-timer__circle">
      <circle class="base-timer__path-elapsed" cx="50" cy="50" r="45"></circle>
      <path
        id="base-timer-path-remaining"
        stroke-dasharray="283"
        class="base-timer__path-remaining ${remainingPathColor}"
        d="
          M 50, 50
          m -45, 0
          a 45,45 0 1,0 90,0
          a 45,45 0 1,0 -90,0
        "
      ></path>
    </g>
  </svg>
  <span id="base-timer-label" class="base-timer__label">${formatTime(
    timeLeft
  )}</span>
</div>
`;


function onTimesUp() {
  clearInterval(timerInterval);
  timePassed = 0;
  gameOver();
}

function startTimer() {
  timerInterval = setInterval(() => {
    timePassed = timePassed += 1;
    timeLeft = TIME_LIMIT - timePassed;
    document.getElementById("base-timer-label").innerHTML = formatTime(
      timeLeft
    );
    setCircleDasharray();
    setRemainingPathColor(timeLeft);

    if (timeLeft === 0) {
      onTimesUp();
    }
  }, 1000);
}

function formatTime(time) {
  const minutes = Math.floor(time / 60);
  let seconds = time % 60;

  if (seconds < 10) {
    seconds = `0${seconds}`;
  }

  return `${minutes}:${seconds}`;
}

function setRemainingPathColor(timeLeft) {
  const { alert, warning, info } = COLOR_CODES;
  if (timeLeft <= alert.threshold) {
    document
      .getElementById("base-timer-path-remaining")
      .classList.remove(warning.color);
    document
      .getElementById("base-timer-path-remaining")
      .classList.add(alert.color);
  } else if (timeLeft <= warning.threshold) {
    document
      .getElementById("base-timer-path-remaining")
      .classList.remove(info.color);
    document
      .getElementById("base-timer-path-remaining")
      .classList.add(warning.color);
  }
}

function calculateTimeFraction() {
  const rawTimeFraction = timeLeft / TIME_LIMIT;
  return rawTimeFraction - (1 / TIME_LIMIT) * (1 - rawTimeFraction);
}

function setCircleDasharray() {
  const circleDasharray = `${(
    calculateTimeFraction() * FULL_DASH_ARRAY
  ).toFixed(0)} 283`;
  document
    .getElementById("base-timer-path-remaining")
    .setAttribute("stroke-dasharray", circleDasharray);
}


    // Timer button
  let timer = document.querySelector(".timer");
  timer.addEventListener("click", () => {
    console.log("Timer clicked");
    startTimer();

  });




  function initPuzzle() {
    pieces = [];
    mouse = {
      x: 0,
      y: 0
    };
    currentPiece = null;
    currentDropPiece = null;
    
    stage.drawImage(
      img,
      0,
      0,
      puzzleWidth,
      puzzleHeight,
      0,
      0,
      puzzleWidth,
      puzzleHeight
    );
    buildPieces();
  }

  function setCanvas() {
    canvas.width = puzzleWidth;
    canvas.height = puzzleHeight;
    canvas.style.border = "10px solid #fff";
    canvas.style.display = "flex";
    canvas.style.margin = "0 auto";
    canvas.style.backgroundColor = "whitesmoke";
    canvas.style.borderRadius = "2%";

  }

  function onImage() {
    pieceWidth = Math.floor(img.width / difficulty);
    pieceHeight = Math.floor(img.height / difficulty);
    puzzleWidth = pieceWidth * difficulty;
    puzzleHeight = pieceHeight * difficulty;
    setCanvas();
    initPuzzle();
  }


  function buildPieces() {
    let i;
    let piece;
    let xPos = 0;
    let yPos = 0;
    for (i = 0; i < difficulty * difficulty; i++) {
      piece = {};
      piece.sx = xPos;
      piece.sy = yPos;
      pieces.push(piece);
      xPos += pieceWidth;
      if (xPos >= puzzleWidth) {
        xPos = 0;
        yPos += pieceHeight;
      }
    }
  }


  function shufflePuzzle() {
    pieces = shuffleArray(pieces);
    stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
    let xPos = 0;
    let yPos = 0;
    for (const piece of pieces) {
      piece.xPos = xPos;
      piece.yPos = yPos;
      stage.drawImage(
        img,
        piece.sx,
        piece.sy,
        pieceWidth,
        pieceHeight,
        xPos,
        yPos,
        pieceWidth,
        pieceHeight
      );
      stage.strokeRect(xPos, yPos, pieceWidth, pieceHeight);
      xPos += pieceWidth;
      if (xPos >= puzzleWidth) {
        xPos = 0;
        yPos += pieceHeight;
      }
    }
    document.onpointerdown = onPuzzleClick;
  }

  function checkPieceClicked() {
    for (const piece of pieces) {
      if (
        mouse.x < piece.xPos ||
        mouse.x > piece.xPos + pieceWidth ||
        mouse.y < piece.yPos ||
        mouse.y > piece.yPos + pieceHeight
      ) {
        //PIECE NOT HIT
      } else {
        return piece;
      }
    }
    return null;
  }

  function updatePuzzle(e) {
    currentDropPiece = null;
    if (e.layerX || e.layerX == 0) {
      mouse.x = e.layerX - canvas.offsetLeft;
      mouse.y = e.layerY - canvas.offsetTop;
    } else if (e.offsetX || e.offsetX == 0) {
      mouse.x = e.offsetX - canvas.offsetLeft;
      mouse.y = e.offsetY - canvas.offsetTop;
    }
    stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
    for (const piece of pieces) {
      if (piece == currentPiece) {
        continue;
      }
      stage.drawImage(
        img,
        piece.sx,
        piece.sy,
        pieceWidth,
        pieceHeight,
        piece.xPos,
        piece.yPos,
        pieceWidth,
        pieceHeight
      );
      stage.strokeRect(piece.xPos, piece.yPos, pieceWidth, pieceHeight);
      if (currentDropPiece == null) {
        if (
          mouse.x < piece.xPos ||
          mouse.x > piece.xPos + pieceWidth ||
          mouse.y < piece.yPos ||
          mouse.y > piece.yPos + pieceHeight
        ) {
          //NOT OVER
        } else {
          currentDropPiece = piece;
          stage.save();
          stage.globalAlpha = 0.4;
          stage.fillStyle = PUZZLE_HOVER_TINT;
          stage.fillRect(
            currentDropPiece.xPos,
            currentDropPiece.yPos,
            pieceWidth,
            pieceHeight
          );
          stage.restore();
        }
      }
    }
    stage.save();
    stage.globalAlpha = 0.6;
    stage.drawImage(
      img,
      currentPiece.sx,
      currentPiece.sy,
      pieceWidth,
      pieceHeight,
      mouse.x - pieceWidth / 2,
      mouse.y - pieceHeight / 2,
      pieceWidth,
      pieceHeight
    );
    stage.restore();
    stage.strokeRect(
      mouse.x - pieceWidth / 2,
      mouse.y - pieceHeight / 2,
      pieceWidth,
      pieceHeight
    );
  }

  function onPuzzleClick(e) {
    if (e.layerX || e.layerX === 0) {
      mouse.x = e.layerX - canvas.offsetLeft;
      mouse.y = e.layerY - canvas.offsetTop;
    } else if (e.offsetX || e.offsetX === 0) {
      mouse.x = e.offsetX - canvas.offsetLeft;
      mouse.y = e.offsetY - canvas.offsetTop;
    }
    currentPiece = checkPieceClicked();
    if (currentPiece !== null) {
      stage.clearRect(
        currentPiece.xPos,
        currentPiece.yPos,
        pieceWidth,
        pieceHeight
      );
      stage.save();
      stage.globalAlpha = 0.9;
      stage.drawImage(
        img,
        currentPiece.sx,
        currentPiece.sy,
        pieceWidth,
        pieceHeight,
        mouse.x - pieceWidth / 2,
        mouse.y - pieceHeight / 2,
        pieceWidth,
        pieceHeight
      );
      stage.restore();
      document.onpointermove = updatePuzzle;
      document.onpointerup = pieceDropped;
    }
  }

  function gameOver() {
    document.onpointerdown = null;
    document.onpointermove = null;
    document.onpointerup = null;
    stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
    initPuzzle();
    console.log("Game over!");
  }

  function pieceDropped(e) {
    document.onpointermove = null;
    document.onpointerup = null;
    if (currentDropPiece !== null) {
      let tmp = {
        xPos: currentPiece.xPos,
        yPos: currentPiece.yPos
      };
      currentPiece.xPos = currentDropPiece.xPos;
      currentPiece.yPos = currentDropPiece.yPos;
      currentDropPiece.xPos = tmp.xPos;
      currentDropPiece.yPos = tmp.yPos;
    }
    resetPuzzleAndCheckWin();
  }

  function resetPuzzleAndCheckWin() {
    stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
    let gameWin = true;
    for (piece of pieces) {
      stage.drawImage(
        img,
        piece.sx,
        piece.sy,
        pieceWidth,
        pieceHeight,
        piece.xPos,
        piece.yPos,
        pieceWidth,
        pieceHeight
      );
      stage.strokeRect(piece.xPos, piece.yPos, pieceWidth, pieceHeight);
      if (piece.xPos != piece.sx || piece.yPos != piece.sy) {
        gameWin = false;
      }
    }
    if (gameWin) {
      setTimeout(gameOver, 500);
      console.log("You won!"); 
          

      updateImageBorder();
    }
  }




// Function to update the selected image border if the puzzle is complete
function updateImageBorder() {
  const imgOptions = document.querySelectorAll(".options");
  let selectedImage = document.querySelector(".option");;
  imgOptions.forEach(function (option) {
    if (option.src == img.src)
      selectedImage = option;
  });
 
  console.log("Image", selectedImage.src);

    selectedImage.style.border = "3px solid green";

    console.log("Green border");
    console.log(img.src);

}

  function shuffleArray(o) {
    for (
      var j, x, i = o.length;
      i;
      j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x
    );
    return o;
  }

  function updateDifficulty(e) {
    stage.clearRect(0, 0, puzzleWidth, puzzleHeight);

    difficulty = e.target.value;
    pieceWidth = Math.floor(img.width / difficulty);
    pieceHeight = Math.floor(img.height / difficulty);
    puzzleWidth = pieceWidth * difficulty;
    puzzleHeight = pieceHeight * difficulty;
    gameOver();
  }
  document.querySelector("#difficulty").oninput = updateDifficulty;


</script>